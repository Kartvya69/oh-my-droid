/**
 * Notepad Wisdom System for Oh-My-Droid
 * Adapted from oh-my-claudecode for Droid
 *
 * Plan-scoped knowledge capture for agents
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync, appendFileSync } from 'fs';
import { join } from 'path';
import type { WisdomEntry, WisdomCategory, PlanWisdom } from '../shared/types.js';
import { NOTEPAD_DIR, ensureStateDirs } from './boulder-state.js';

/**
 * Get notepad directory for a plan
 */
function getNotepadDir(planName: string): string {
  return join(NOTEPAD_DIR, planName);
}

/**
 * Get file path for a wisdom category
 */
function getWisdomFilePath(planName: string, category: WisdomCategory): string {
  return join(getNotepadDir(planName), `${category}.md`);
}

/**
 * Initialize notepad for a plan
 */
export function initPlanNotepad(planName: string): boolean {
  try {
    ensureStateDirs();
    const dir = getNotepadDir(planName);
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    // Initialize files if they don't exist
    const categories: WisdomCategory[] = ['learnings', 'decisions', 'issues', 'problems'];
    for (const category of categories) {
      const path = getWisdomFilePath(planName, category);
      if (!existsSync(path)) {
        writeFileSync(
          path,
          `# ${category.charAt(0).toUpperCase() + category.slice(1)}\n\n<!-- Auto-generated by Oh-My-Droid -->\n`
        );
      }
    }

    return true;
  } catch (error) {
    console.warn(`Warning: Could not initialize notepad for ${planName}`);
    return false;
  }
}

/**
 * Add a wisdom entry
 */
function addWisdomEntry(
  planName: string,
  category: WisdomCategory,
  content: string
): boolean {
  initPlanNotepad(planName);

  try {
    const path = getWisdomFilePath(planName, category);
    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);
    const entry = `\n## ${timestamp}\n${content}\n`;

    appendFileSync(path, entry);
    return true;
  } catch (error) {
    console.warn(`Warning: Could not add ${category} to notepad`);
    return false;
  }
}

/**
 * Add a learning
 */
export function addLearning(planName: string, content: string): boolean {
  return addWisdomEntry(planName, 'learnings', content);
}

/**
 * Add a decision
 */
export function addDecision(planName: string, content: string): boolean {
  return addWisdomEntry(planName, 'decisions', content);
}

/**
 * Add an issue
 */
export function addIssue(planName: string, content: string): boolean {
  return addWisdomEntry(planName, 'issues', content);
}

/**
 * Add a problem
 */
export function addProblem(planName: string, content: string): boolean {
  return addWisdomEntry(planName, 'problems', content);
}

/**
 * Parse wisdom entries from markdown content
 */
function parseWisdomEntries(content: string): WisdomEntry[] {
  const entries: WisdomEntry[] = [];
  const lines = content.split('\n');

  let currentEntry: { timestamp?: string; content: string[] } | null = null;

  for (const line of lines) {
    const headerMatch = line.match(/^## (\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})$/);
    if (headerMatch) {
      if (currentEntry && currentEntry.timestamp) {
        entries.push({
          timestamp: currentEntry.timestamp,
          content: currentEntry.content.join('\n').trim(),
        });
      }
      currentEntry = { timestamp: headerMatch[1], content: [] };
    } else if (currentEntry && line.trim()) {
      currentEntry.content.push(line);
    }
  }

  if (currentEntry && currentEntry.timestamp) {
    entries.push({
      timestamp: currentEntry.timestamp,
      content: currentEntry.content.join('\n').trim(),
    });
  }

  return entries;
}

/**
 * Read plan wisdom
 */
export function readPlanWisdom(planName: string): PlanWisdom | null {
  try {
    const categories: WisdomCategory[] = ['learnings', 'decisions', 'issues', 'problems'];
    const wisdom: PlanWisdom = {
      planName,
      learnings: [],
      decisions: [],
      issues: [],
      problems: [],
    };

    for (const category of categories) {
      const path = getWisdomFilePath(planName, category);
      if (existsSync(path)) {
        const content = readFileSync(path, 'utf-8');
        wisdom[category] = parseWisdomEntries(content);
      }
    }

    return wisdom;
  } catch (error) {
    console.warn(`Warning: Could not read wisdom for ${planName}`);
    return null;
  }
}

/**
 * Get wisdom summary
 */
export function getWisdomSummary(planName: string): string {
  const wisdom = readPlanWisdom(planName);
  if (!wisdom) {
    return `No wisdom recorded for plan: ${planName}`;
  }

  const sections: string[] = [];

  if (wisdom.learnings.length > 0) {
    sections.push(`## Learnings (${wisdom.learnings.length})`);
    wisdom.learnings.slice(-3).forEach((l) => {
      sections.push(`- ${l.timestamp}: ${l.content.slice(0, 100)}...`);
    });
  }

  if (wisdom.decisions.length > 0) {
    sections.push(`\n## Decisions (${wisdom.decisions.length})`);
    wisdom.decisions.slice(-3).forEach((d) => {
      sections.push(`- ${d.timestamp}: ${d.content.slice(0, 100)}...`);
    });
  }

  if (wisdom.issues.length > 0) {
    sections.push(`\n## Issues (${wisdom.issues.length})`);
    wisdom.issues.slice(-3).forEach((i) => {
      sections.push(`- ${i.timestamp}: ${i.content.slice(0, 100)}...`);
    });
  }

  if (wisdom.problems.length > 0) {
    sections.push(`\n## Problems (${wisdom.problems.length})`);
    wisdom.problems.slice(-3).forEach((p) => {
      sections.push(`- ${p.timestamp}: ${p.content.slice(0, 100)}...`);
    });
  }

  return sections.join('\n') || 'No wisdom recorded yet.';
}
